-- TASK 1 DDL for actors table: Create a DDL for an actors table with the following fields:
    -- films: An array of struct with the following fields:
        -- film: The name of the film.
        -- votes: The number of votes the film received.
        -- rating: The rating of the film.
        -- filmid: A unique identifier for each film.
    -- quality_class: This field represents an actor's performance quality, determined by the average rating of movies of their most recent year. It's categorized as follows:
        -- star: Average rating > 8.
        -- good: Average rating > 7 and ≤ 8.
        -- average: Average rating > 6 and ≤ 7.
        -- bad: Average rating ≤ 6.
    -- is_active: A BOOLEAN field that indicates whether an actor is currently active in the film industry (i.e., making films this year).
DROP TABLE actors;
DROP TYPE quality_class CASCADE;
DROP TYPE films CASCADE;

CREATE TYPE films AS (
	film TEXT,
	votes INTEGER,
	rating REAL,
	filmid TEXT
);
CREATE TYPE quality_class AS ENUM('star', 'good', 'average', 'bad');
CREATE TABLE actors (
	actor TEXT,
	actorid TEXT,
	films films[],
	year INTEGER,
	quality_class quality_class,
	is_active BOOLEAN DEFAULT FALSE
);



-- TASK 2 Cumulative table generation query: Write a query that populates the actors table one year at a time.
-- START OF INSERT -- 1970, 2021
WITH years AS (
  SELECT GENERATE_SERIES(1970, 2020) AS year
),
first_years AS (
  SELECT actorid, MIN(year) AS first_year
  FROM actor_films
  GROUP BY actorid
),
actor_years AS (
  SELECT
    f.actorid,
    y.year
  FROM first_years f
  JOIN years y ON y.year >= f.first_year
),
films_cumulative AS (
  SELECT
    ay.actorid,
    ay.year,
    ARRAY_REMOVE(ARRAY_AGG(
      CASE WHEN af.year <= ay.year THEN ROW(af.film, af.votes, af.rating, af.filmid)::films ELSE NULL END
    ), NULL) AS films
  FROM actor_years ay
  LEFT JOIN actor_films af ON ay.actorid = af.actorid
  GROUP BY ay.actorid, ay.year
),
quality_and_active AS (
  SELECT
    fc.actorid,
    fc.year,
    fc.films,
    CASE
      WHEN array_length(fc.films, 1) > 0 THEN
        CASE
          WHEN (SELECT AVG((f).rating) FROM UNNEST(fc.films) AS f) > 8 THEN 'star'::quality_class
          WHEN (SELECT AVG((f).rating) FROM UNNEST(fc.films) AS f) > 7 THEN 'good'::quality_class
          WHEN (SELECT AVG((f).rating) FROM UNNEST(fc.films) AS f) > 6 THEN 'average'::quality_class
          ELSE 'bad'::quality_class
        END
      ELSE 'bad'::quality_class
    END AS quality_class,
    EXISTS (
      SELECT 1 FROM actor_films af2 WHERE af2.actorid = fc.actorid AND af2.year = fc.year
    ) AS is_active
  FROM films_cumulative fc
)
INSERT INTO actors (actor, actorid, year, films, quality_class, is_active)
SELECT
  COALESCE(af.actor, '-') AS actor,
  qa.actorid,
  qa.year,
  qa.films,
  qa.quality_class,
  qa.is_active
FROM quality_and_active qa
LEFT JOIN (
  SELECT DISTINCT actorid, actor
  FROM actor_films
) af ON qa.actorid = af.actorid
ORDER BY qa.actorid, qa.year;



-- TASK 3 DDL for actors_history_scd table: 
	-- Create a DDL for an actors_history_scd table with the following features:
		-- Implements type 2 dimension modeling (i.e., includes start_date and end_date fields).
		-- Tracks quality_class and is_active status for each actor in the actors table.
DROP TABLE IF EXISTS actors_history_scd;
CREATE TABLE actors_history_scd (
	actorid TEXT,
	actor_name TEXT,
	quality_class quality_class,
	is_active BOOLEAN,
	start_date INTEGER,
	end_date INTEGER,
	current_year INTEGER,
	PRIMARY KEY(actorid, start_date)
);

-- TASK 4 Backfill query for actors_history_scd: 
	--  Write a "backfill" query that can populate the entire actors_history_scd table in a single query.

INSERT INTO actors_history_scd
WITH with_previous AS (
	SELECT 
		actorid,
		actor AS actor_name,
		year AS current_year,
		quality_class, 
		is_active,
		LAG(quality_class) OVER (PARTITION BY actorid ORDER BY year) AS previous_quality_class,
		LAG(is_active) OVER (PARTITION BY actorid ORDER BY year) AS previous_is_active
	FROM actors
	WHERE year <= 2021
), with_indicators AS (
	SELECT *, 
		CASE 
			WHEN quality_class <> previous_quality_class THEN 1
			WHEN is_active <> previous_is_active THEN 1 
			ELSE 0
		END AS change_indicator
	FROM with_previous
), with_streaks AS (
	SELECT *, 
		SUM(change_indicator) OVER (PARTITION BY actorid ORDER BY current_year) AS streak_identifier
	FROM with_indicators
)
SELECT 
	actorid,
	actor_name,
	quality_class,
	is_active,
	MIN(current_year) AS start_date,
	MAX(current_year) AS end_date,
	2020 AS current_year
FROM with_streaks
GROUP BY actorid, actor_name, streak_identifier, is_active, quality_class
ORDER BY actorid, start_date;


-- TASAK 5 Incremental query for actors_history_scd:
	-- Write an "incremental" query that combines the previous year's SCD data with new incoming data 
	-- from the actors table.
DROP TYPE scd_type CASCADE;
CREATE TYPE scd_type AS(
	quality_class quality_class,
	is_active BOOLEAN,
	start_season INTEGER,
	end_season INTEGER
);


-- Drop and re-create SCD type if needed
DROP TYPE IF EXISTS scd_type CASCADE;
CREATE TYPE scd_type AS (
	quality_class quality_class,
	is_active BOOLEAN,
	start_date INTEGER,
	end_date INTEGER
);

WITH last_year_scd AS (
	SELECT *
	FROM actors_history_scd
	WHERE current_year = 2020
	  AND end_date = 2020
), historical_scd AS (
	SELECT *
	FROM actors_history_scd
	WHERE current_year = 2020
	  AND end_date < 2020
), this_year_data AS (
	SELECT *
	FROM actors
	WHERE year = 2021
), unchanged_records AS (
	SELECT 
		ts.actorid,
		COALESCE(ts.actor, '-') AS actor_name,
		ts.quality_class,
		ts.is_active,
		ls.start_date,
		ts.year AS end_date,
		ts.year AS current_year
	FROM this_year_data ts
	JOIN last_year_scd ls ON ts.actorid = ls.actorid
	WHERE 
		ts.quality_class = ls.quality_class
		AND ts.is_active = ls.is_active
), changed_records AS (
	SELECT 
		ts.actorid,
		COALESCE(ts.actor, '-') AS actor_name,
		UNNEST(ARRAY[
			ROW(
				ls.quality_class, 
				ls.is_active, 
				ls.start_date,
				ls.end_date
			)::scd_type,
			ROW(
				ts.quality_class, 
				ts.is_active, 
				ts.year,
				ts.year
			)::scd_type
		]) AS record
	FROM this_year_data ts
	LEFT JOIN last_year_scd ls ON ts.actorid = ls.actorid
	WHERE 
		ts.quality_class <> ls.quality_class
		OR ts.is_active <> ls.is_active
), unnested_changed_records AS (
	SELECT
		actorid,
		actor_name,
		(record).quality_class,
		(record).is_active,
		(record).start_date,
		(record).end_date,
		2021 AS current_year
	FROM changed_records
), new_records AS (
	SELECT 
		ts.actorid,
		COALESCE(ts.actor, '-') AS actor_name,
		ts.quality_class,
		ts.is_active,
		ts.year AS start_date,
		ts.year AS end_date,
		ts.year AS current_year
	FROM this_year_data ts
	LEFT JOIN last_year_scd ls ON ts.actorid = ls.actorid
	WHERE ls.actorid IS NULL
)
-- Final union of all updates
SELECT * FROM historical_scd
UNION ALL
SELECT * FROM unchanged_records
UNION ALL
SELECT * FROM unnested_changed_records
UNION ALL
SELECT * FROM new_records;








